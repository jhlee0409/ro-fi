/**
 * 저장 엔진 - 마크다운 파일 저장 및 Git 커밋
 */

import { existsSync, writeFileSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { execSync } from 'child_process';

export class Storage {
  constructor(config) {
    this.config = config;
    this.contentDir = join(process.cwd(), 'src', 'content');
    this.novelsDir = join(this.contentDir, 'novels');
    this.chaptersDir = join(this.contentDir, 'chapters');
  }

  // 메인 저장 함수
  async save(result) {
    console.log('💾 저장 중...');

    try {
      if (result.type === 'new_novel') {
        await this.saveNewNovel(result);
      } else {
        await this.saveChapter(result);
      }

      await this.gitCommit(result);
      console.log('✅ 저장 완료');

    } catch (error) {
      console.error('💥 저장 실패:', error.message);
      throw error;
    }
  }

  // 새 소설 저장 (소설 정보 + 1화)
  async saveNewNovel(result) {
    // 소설 메타데이터 저장
    const novelPath = join(this.novelsDir, `${result.slug}.md`);
    const novelContent = this.buildNovelMarkdown(result);
    writeFileSync(novelPath, novelContent);

    // 1화 저장
    const chapterPath = join(this.chaptersDir, `${result.slug}-ch1.md`);
    const chapterContent = this.buildChapterMarkdown(result.chapter, result.slug, 1);
    writeFileSync(chapterPath, chapterContent);

    console.log(`📚 새 소설 저장: ${result.title} (1화 포함)`);
  }

  // 기존 소설의 새 챕터 저장
  async saveChapter(result) {
    const chapterPath = join(this.chaptersDir, `${result.slug}-ch${result.chapter.number}.md`);
    const chapterContent = this.buildChapterMarkdown(result.chapter, result.slug, result.chapter.number);
    writeFileSync(chapterPath, chapterContent);

    // 완결인 경우 소설 메타데이터 업데이트
    if (result.type === 'completion') {
      await this.updateNovelStatus(result.slug, '완결', result.chapter.number);
    } else {
      await this.updateNovelChapterCount(result.slug, result.chapter.number);
    }

    console.log(`📖 챕터 저장: ${result.title} ${result.chapter.number}화`);
  }

  // 소설 메타데이터 마크다운 생성
  buildNovelMarkdown(result) {
    const now = new Date().toISOString().split('T')[0];
    
    return `---
title: ${result.title}
slug: ${result.slug}
author: Gemini 2.5 Pro Simple System
status: 연재 중
summary: >-
  ${result.summary}
tropes:
${result.tropes.map(trope => `  - ${trope}`).join('\n')}
publishedDate: '${now}'
totalChapters: 1
rating: 0
gemini25pro: true
characterConsistent: true
autoGenerated: true
---
`;
  }

  // 챕터 마크다운 생성
  buildChapterMarkdown(chapter, novelSlug, chapterNumber) {
    const now = new Date().toISOString().split('T')[0];
    
    return `---
title: '${chapter.title}'
novel: ${novelSlug}
chapterNumber: ${chapterNumber}
publicationDate: '${now}'
wordCount: ${chapter.wordCount}
contentRating: 15+
autoGenerated: true
lastGenerated: '${new Date().toISOString()}'
---

${chapter.content}
`;
  }

  // 소설 상태 업데이트
  async updateNovelStatus(slug, status, totalChapters) {
    const novelPath = join(this.novelsDir, `${slug}.md`);
    
    if (!existsSync(novelPath)) {
      throw new Error(`소설 파일을 찾을 수 없음: ${slug}`);
    }

    let content = readFileSync(novelPath, 'utf-8');
    
    // 상태 업데이트
    content = content.replace(/status: .+/, `status: ${status}`);
    content = content.replace(/totalChapters: \d+/, `totalChapters: ${totalChapters}`);
    
    // 완결일 추가 (완결인 경우)
    if (status === '완결' && !content.includes('completedDate:')) {
      const now = new Date().toISOString().split('T')[0];
      content = content.replace(/publishedDate: '(.+)'/, 
        `publishedDate: '$1'\ncompletedDate: '${now}'`);
    }

    writeFileSync(novelPath, content);
  }

  // 소설 챕터 수 업데이트
  async updateNovelChapterCount(slug, chapterCount) {
    const novelPath = join(this.novelsDir, `${slug}.md`);
    
    if (!existsSync(novelPath)) {
      throw new Error(`소설 파일을 찾을 수 없음: ${slug}`);
    }

    let content = readFileSync(novelPath, 'utf-8');
    content = content.replace(/totalChapters: \d+/, `totalChapters: ${chapterCount}`);
    
    writeFileSync(novelPath, content);
  }

  // Git 커밋
  async gitCommit(result) {
    try {
      // Git 설정 확인
      this.ensureGitConfig();

      // 변경사항 추가
      execSync('git add src/content/', { cwd: process.cwd(), stdio: 'inherit' });

      // 커밋 메시지 생성
      const commitMessage = this.buildCommitMessage(result);
      
      // 커밋 (변경사항이 없으면 무시)
      try {
        execSync(`git commit -m "${commitMessage}"`, { 
          cwd: process.cwd(), 
          stdio: 'inherit' 
        });
        console.log(`🔄 Git 커밋 완료: ${commitMessage}`);
      } catch (error) {
        if (error.message.includes('nothing to commit')) {
          console.log('📝 커밋할 변경사항 없음');
        } else {
          throw error;
        }
      }

    } catch (error) {
      console.error('⚠️  Git 커밋 실패:', error.message);
      // Git 실패는 전체 프로세스를 중단시키지 않음
    }
  }

  ensureGitConfig() {
    try {
      execSync('git config user.name', { cwd: process.cwd(), stdio: 'pipe' });
    } catch {
      execSync('git config user.name "RO-FAN AI System"', { cwd: process.cwd() });
    }

    try {
      execSync('git config user.email', { cwd: process.cwd(), stdio: 'pipe' });
    } catch {
      execSync('git config user.email "ai-system@ro-fan.local"', { cwd: process.cwd() });
    }
  }

  buildCommitMessage(result) {
    switch (result.type) {
      case 'new_novel':
        return `🆕 새 소설: ${result.title} (1화)`;
      case 'completion':
        return `🏁 완결: ${result.title} (${result.chapter.number}화 완결)`;
      default:
        return `📖 연재: ${result.title} ${result.chapter.number}화 업로드`;
    }
  }

  // 유틸리티: 백업 생성
  createBackup(filePath) {
    if (existsSync(filePath)) {
      const backupPath = `${filePath}.backup.${Date.now()}`;
      const content = readFileSync(filePath, 'utf-8');
      writeFileSync(backupPath, content);
      return backupPath;
    }
    return null;
  }

  // 유틸리티: 파일 존재 확인
  fileExists(slug, chapterNumber = null) {
    if (chapterNumber) {
      const chapterPath = join(this.chaptersDir, `${slug}-ch${chapterNumber}.md`);
      return existsSync(chapterPath);
    } else {
      const novelPath = join(this.novelsDir, `${slug}.md`);
      return existsSync(novelPath);
    }
  }
}