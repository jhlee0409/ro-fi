/**
 * ì €ì¥ ì—”ì§„ - ë§ˆí¬ë‹¤ìš´ íŒŒì¼ ì €ì¥ ë° Git ì»¤ë°‹
 */

import { existsSync, writeFileSync, readFileSync } from 'fs';
import { join, dirname } from 'path';
import { execSync } from 'child_process';

export class Storage {
  constructor(config) {
    this.config = config;
    this.contentDir = join(process.cwd(), 'src', 'content');
    this.novelsDir = join(this.contentDir, 'novels');
    this.chaptersDir = join(this.contentDir, 'chapters');
  }

  // ë©”ì¸ ì €ì¥ í•¨ìˆ˜
  async save(result) {
    console.log('ğŸ’¾ ì €ì¥ ì¤‘...');

    try {
      if (result.type === 'new_novel') {
        await this.saveNewNovel(result);
      } else {
        await this.saveChapter(result);
      }

      await this.gitCommit(result);
      console.log('âœ… ì €ì¥ ì™„ë£Œ');

    } catch (error) {
      console.error('ğŸ’¥ ì €ì¥ ì‹¤íŒ¨:', error.message);
      throw error;
    }
  }

  // ìƒˆ ì†Œì„¤ ì €ì¥ (ì†Œì„¤ ì •ë³´ + 1í™”)
  async saveNewNovel(result) {
    // ì†Œì„¤ ë©”íƒ€ë°ì´í„° ì €ì¥
    const novelPath = join(this.novelsDir, `${result.slug}.md`);
    const novelContent = this.buildNovelMarkdown(result);
    writeFileSync(novelPath, novelContent);

    // 1í™” ì €ì¥
    const chapterPath = join(this.chaptersDir, `${result.slug}-ch1.md`);
    const chapterContent = this.buildChapterMarkdown(result.chapter, result.slug, 1);
    writeFileSync(chapterPath, chapterContent);

    console.log(`ğŸ“š ìƒˆ ì†Œì„¤ ì €ì¥: ${result.title} (1í™” í¬í•¨)`);
  }

  // ê¸°ì¡´ ì†Œì„¤ì˜ ìƒˆ ì±•í„° ì €ì¥
  async saveChapter(result) {
    const chapterPath = join(this.chaptersDir, `${result.slug}-ch${result.chapter.number}.md`);
    const chapterContent = this.buildChapterMarkdown(result.chapter, result.slug, result.chapter.number);
    writeFileSync(chapterPath, chapterContent);

    // ì™„ê²°ì¸ ê²½ìš° ì†Œì„¤ ë©”íƒ€ë°ì´í„° ì—…ë°ì´íŠ¸
    if (result.type === 'completion') {
      await this.updateNovelStatus(result.slug, 'ì™„ê²°', result.chapter.number);
    } else {
      await this.updateNovelChapterCount(result.slug, result.chapter.number);
    }

    console.log(`ğŸ“– ì±•í„° ì €ì¥: ${result.title} ${result.chapter.number}í™”`);
  }

  // ì†Œì„¤ ë©”íƒ€ë°ì´í„° ë§ˆí¬ë‹¤ìš´ ìƒì„±
  buildNovelMarkdown(result) {
    const now = new Date().toISOString().split('T')[0];
    
    return `---
title: ${result.title}
slug: ${result.slug}
author: Gemini 2.5 Pro Simple System
status: ì—°ì¬ ì¤‘
summary: >-
  ${result.summary}
tropes:
${result.tropes.map(trope => `  - ${trope}`).join('\n')}
publishedDate: '${now}'
totalChapters: 1
rating: 0
gemini25pro: true
characterConsistent: true
autoGenerated: true
---
`;
  }

  // ì±•í„° ë§ˆí¬ë‹¤ìš´ ìƒì„±
  buildChapterMarkdown(chapter, novelSlug, chapterNumber) {
    const now = new Date().toISOString().split('T')[0];
    
    return `---
title: '${chapter.title}'
novel: ${novelSlug}
chapterNumber: ${chapterNumber}
publicationDate: '${now}'
wordCount: ${chapter.wordCount}
contentRating: 15+
autoGenerated: true
lastGenerated: '${new Date().toISOString()}'
---

${chapter.content}
`;
  }

  // ì†Œì„¤ ìƒíƒœ ì—…ë°ì´íŠ¸
  async updateNovelStatus(slug, status, totalChapters) {
    const novelPath = join(this.novelsDir, `${slug}.md`);
    
    if (!existsSync(novelPath)) {
      throw new Error(`ì†Œì„¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${slug}`);
    }

    let content = readFileSync(novelPath, 'utf-8');
    
    // ìƒíƒœ ì—…ë°ì´íŠ¸
    content = content.replace(/status: .+/, `status: ${status}`);
    content = content.replace(/totalChapters: \d+/, `totalChapters: ${totalChapters}`);
    
    // ì™„ê²°ì¼ ì¶”ê°€ (ì™„ê²°ì¸ ê²½ìš°)
    if (status === 'ì™„ê²°' && !content.includes('completedDate:')) {
      const now = new Date().toISOString().split('T')[0];
      content = content.replace(/publishedDate: '(.+)'/, 
        `publishedDate: '$1'\ncompletedDate: '${now}'`);
    }

    writeFileSync(novelPath, content);
  }

  // ì†Œì„¤ ì±•í„° ìˆ˜ ì—…ë°ì´íŠ¸
  async updateNovelChapterCount(slug, chapterCount) {
    const novelPath = join(this.novelsDir, `${slug}.md`);
    
    if (!existsSync(novelPath)) {
      throw new Error(`ì†Œì„¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${slug}`);
    }

    let content = readFileSync(novelPath, 'utf-8');
    content = content.replace(/totalChapters: \d+/, `totalChapters: ${chapterCount}`);
    
    writeFileSync(novelPath, content);
  }

  // Git ì»¤ë°‹
  async gitCommit(result) {
    try {
      // Git ì„¤ì • í™•ì¸
      this.ensureGitConfig();

      // ë³€ê²½ì‚¬í•­ ì¶”ê°€
      execSync('git add src/content/', { cwd: process.cwd(), stdio: 'inherit' });

      // ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
      const commitMessage = this.buildCommitMessage(result);
      
      // ì»¤ë°‹ (ë³€ê²½ì‚¬í•­ì´ ì—†ìœ¼ë©´ ë¬´ì‹œ)
      try {
        execSync(`git commit -m "${commitMessage}"`, { 
          cwd: process.cwd(), 
          stdio: 'inherit' 
        });
        console.log(`ğŸ”„ Git ì»¤ë°‹ ì™„ë£Œ: ${commitMessage}`);
      } catch (error) {
        if (error.message.includes('nothing to commit')) {
          console.log('ğŸ“ ì»¤ë°‹í•  ë³€ê²½ì‚¬í•­ ì—†ìŒ');
        } else {
          throw error;
        }
      }

    } catch (error) {
      console.error('âš ï¸  Git ì»¤ë°‹ ì‹¤íŒ¨:', error.message);
      // Git ì‹¤íŒ¨ëŠ” ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨ì‹œí‚¤ì§€ ì•ŠìŒ
    }
  }

  ensureGitConfig() {
    try {
      execSync('git config user.name', { cwd: process.cwd(), stdio: 'pipe' });
    } catch {
      execSync('git config user.name "RO-FAN AI System"', { cwd: process.cwd() });
    }

    try {
      execSync('git config user.email', { cwd: process.cwd(), stdio: 'pipe' });
    } catch {
      execSync('git config user.email "ai-system@ro-fan.local"', { cwd: process.cwd() });
    }
  }

  buildCommitMessage(result) {
    switch (result.type) {
      case 'new_novel':
        return `ğŸ†• ìƒˆ ì†Œì„¤: ${result.title} (1í™”)`;
      case 'completion':
        return `ğŸ ì™„ê²°: ${result.title} (${result.chapter.number}í™” ì™„ê²°)`;
      default:
        return `ğŸ“– ì—°ì¬: ${result.title} ${result.chapter.number}í™” ì—…ë¡œë“œ`;
    }
  }

  // ìœ í‹¸ë¦¬í‹°: ë°±ì—… ìƒì„±
  createBackup(filePath) {
    if (existsSync(filePath)) {
      const backupPath = `${filePath}.backup.${Date.now()}`;
      const content = readFileSync(filePath, 'utf-8');
      writeFileSync(backupPath, content);
      return backupPath;
    }
    return null;
  }

  // ìœ í‹¸ë¦¬í‹°: íŒŒì¼ ì¡´ì¬ í™•ì¸
  fileExists(slug, chapterNumber = null) {
    if (chapterNumber) {
      const chapterPath = join(this.chaptersDir, `${slug}-ch${chapterNumber}.md`);
      return existsSync(chapterPath);
    } else {
      const novelPath = join(this.novelsDir, `${slug}.md`);
      return existsSync(novelPath);
    }
  }
}