/**
 * üß™ Phase 6 Integration Tests
 * Î∞∞Ìè¨ Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú ÌÜµÌï© ÌÖåÏä§Ìä∏
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { DeploymentManagementSystem } from '../lib/deployment-management-system.js';
import { MonitoringAlertingSystem } from '../lib/monitoring-alerting-system.js';
import { HealthStatusDashboard } from '../lib/health-status-dashboard.js';

describe('Phase 6 System Integration', () => {
  let deploymentSystem: DeploymentManagementSystem;
  let monitoringSystem: MonitoringAlertingSystem;
  let healthDashboard: HealthStatusDashboard;

  beforeEach(() => {
    deploymentSystem = new DeploymentManagementSystem();
    monitoringSystem = new MonitoringAlertingSystem();
    healthDashboard = new HealthStatusDashboard();
  });

  afterEach(() => {
    // Ï†ïÎ¶¨ ÏûëÏóÖ
    vi.clearAllMocks();
  });

  describe('Cross-System Integration', () => {
    it('should integrate deployment events with monitoring system', async () => {
      // 1. ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
      const pipeline = deploymentSystem.createPipeline({
        name: 'Integration Test Pipeline',
        environment: 'staging',
        stages: [{
          id: 'deploy',
          name: 'Deploy',
          type: 'deploy',
          dependencies: [],
          configuration: {},
          timeoutMinutes: 10,
          retryPolicy: { enabled: false, maxRetries: 0, backoffSeconds: 0 },
          healthChecks: [],
          rollbackConditions: []
        }],
        deploymentStrategy: {
          type: 'rolling',
          validation: {
            healthChecks: ['http'],
            timeout: 300,
            autoRollback: true
          }
        },
        configuration: {
          buildCommands: [],
          testCommands: [],
          deployCommands: ['echo "deploying"'],
          environmentVariables: new Map(),
          artifacts: [],
          security: {
            secretScanning: false,
            vulnerabilityCheck: false,
            complianceCheck: false
          }
        },
        notifications: {
          channels: ['email'],
          events: ['start', 'success', 'failure'],
          recipients: ['test@example.com']
        }
      });

      // 2. Î∞∞Ìè¨ Î©îÌä∏Î¶≠ Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
      monitoringSystem.createAlertRule({
        name: 'Deployment Failure Alert',
        metric: 'deployment.failure_rate',
        condition: 'greater_than',
        threshold: 5,
        severity: 'critical',
        enabled: true,
        description: 'Deployment failure rate is too high',
        actions: ['email', 'slack']
      });

      // 3. Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÉùÏÑ±
      const healthCheck = healthDashboard.createHealthCheck({
        name: 'Deployment Health',
        type: 'application',
        enabled: true,
        interval: 30000,
        timeout: 5000,
        configuration: {
          pipelineId: pipeline.id
        },
        thresholds: {
          warning: 1000,
          critical: 3000
        },
        dependencies: []
      });

      // 4. Î∞∞Ìè¨ Ïã§Ìñâ
      const execution = await deploymentSystem.executeDeployment(
        pipeline.id,
        'v1.0.0',
        'integration-test',
        { approved: true }
      );

      // 5. ÌÜµÌï© Í≤ÄÏ¶ù
      expect(execution).toBeDefined();
      expect(execution.pipelineId).toBe(pipeline.id);
      
      // Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖúÏù¥ Î∞∞Ìè¨ Ïù¥Î≤§Ìä∏Î•º Í∞êÏßÄÌñàÎäîÏßÄ ÌôïÏù∏
      const systemStatus = monitoringSystem.getSystemStatus();
      expect(systemStatus).toBeDefined();
      
      // Ìó¨Ïä§Ï≤¥ÌÅ¨Í∞Ä Ïã§ÌñâÎêòÎäîÏßÄ ÌôïÏù∏
      const healthResult = await healthDashboard.executeHealthCheck(healthCheck.id);
      expect(healthResult).toBeDefined();
    });

    it('should coordinate alerts between monitoring and health systems', async () => {
      // 1. Î™®ÎãàÌÑ∞ÎßÅ ÏïåÎ¶º Í∑úÏπô ÏÉùÏÑ±
      const alertRule = monitoringSystem.createAlertRule({
        name: 'System Resource Alert',
        metric: 'cpu.usage',
        condition: 'greater_than',
        threshold: 80,
        severity: 'warning',
        enabled: true,
        description: 'CPU usage is high',
        actions: ['email']
      });

      // 2. Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏïåÎ¶º ÏÑ§Ï†ï
      const healthCheck = healthDashboard.createHealthCheck({
        name: 'CPU Health Check',
        type: 'system',
        enabled: true,
        interval: 15000,
        timeout: 3000,
        configuration: {
          cpuThreshold: 80
        },
        thresholds: {
          warning: 80,
          critical: 95
        },
        dependencies: []
      });

      healthDashboard.configureHealthAlert({
        checkId: healthCheck.id,
        warningAlert: {
          enabled: true,
          channels: ['email'],
          throttle: 300
        },
        criticalAlert: {
          enabled: true,
          channels: ['email', 'slack'],
          throttle: 60
        }
      });

      // 3. ÎÜíÏùÄ CPU ÏÇ¨Ïö©Î•† ÏãúÎÆ¨Î†àÏù¥ÏÖò
      monitoringSystem.recordMetric('cpu.usage', 85);

      // 4. ÏïåÎ¶º ÌèâÍ∞Ä
      const monitoringAlerts = await monitoringSystem.evaluateAlertRules();
      const healthResult = await healthDashboard.executeHealthCheck(healthCheck.id);

      // 5. ÏñëÏ™Ω ÏãúÏä§ÌÖúÏóêÏÑú ÏïåÎ¶ºÏù¥ Ìä∏Î¶¨Í±∞ÎêòÎäîÏßÄ ÌôïÏù∏
      expect(monitoringAlerts).toBeDefined();
      expect(healthResult).toBeDefined();
      
      // CPU ÏÇ¨Ïö©Î•†Ïù¥ ÎÜíÏúºÎ©¥ Ìó¨Ïä§Ï≤¥ÌÅ¨Í∞Ä Í≤ΩÍ≥† ÏÉÅÌÉúÍ∞Ä Îê† Ïàò ÏûàÏùå
      if (healthResult.responseTime > healthCheck.thresholds.warning) {
        expect(['warning', 'critical']).toContain(healthResult.status);
      }
    });

    it('should provide unified system status across all components', async () => {
      // 1. Î∞∞Ìè¨ ÏãúÏä§ÌÖú ÏÉÅÌÉú
      const deploymentStatus = deploymentSystem.getSystemStatus();
      
      // 2. Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú ÏÉÅÌÉú
      const monitoringStatus = monitoringSystem.getSystemStatus();
      
      // 3. Ìó¨Ïä§ ÎåÄÏãúÎ≥¥Îìú ÏÉÅÌÉú
      const healthStatus = healthDashboard.getSystemHealth();

      // 4. ÌÜµÌï© ÏÉÅÌÉú Í≤ÄÏ¶ù
      expect(deploymentStatus).toBeDefined();
      expect(deploymentStatus.systemHealth).toBeDefined();
      
      expect(monitoringStatus).toBeDefined();
      expect(monitoringStatus.overallHealth).toBeDefined();
      
      expect(healthStatus).toBeDefined();
      expect(healthStatus.overall).toBeDefined();

      // 5. Î™®Îì† ÏãúÏä§ÌÖúÏù¥ Í±¥Í∞ïÌïú ÏÉÅÌÉúÎ°ú ÏãúÏûëÌï¥Ïïº Ìï®
      expect(deploymentStatus.systemHealth).toBe('healthy');
      expect(monitoringStatus.overallHealth).toBe('healthy');
      expect(healthStatus.overall).toBe('healthy');
    });
  });

  describe('End-to-End Deployment Workflow', () => {
    it('should complete full deployment lifecycle with monitoring', async () => {
      // 1. Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
      const pipeline = deploymentSystem.createPipeline({
        name: 'E2E Test Pipeline',
        environment: 'production',
        stages: [
          {
            id: 'build',
            name: 'Build',
            type: 'build',
            dependencies: [],
            configuration: {},
            timeoutMinutes: 15,
            retryPolicy: { enabled: true, maxRetries: 2, backoffSeconds: 30 },
            healthChecks: [],
            rollbackConditions: []
          },
          {
            id: 'test',
            name: 'Test',
            type: 'test',
            dependencies: ['build'],
            configuration: {},
            timeoutMinutes: 20,
            retryPolicy: { enabled: true, maxRetries: 1, backoffSeconds: 60 },
            healthChecks: [],
            rollbackConditions: []
          },
          {
            id: 'deploy',
            name: 'Deploy',
            type: 'deploy',
            dependencies: ['test'],
            configuration: {},
            timeoutMinutes: 10,
            retryPolicy: { enabled: false, maxRetries: 0, backoffSeconds: 0 },
            healthChecks: [{
              type: 'http',
              endpoint: '/health',
              expectedStatus: 200,
              timeout: 30
            }],
            rollbackConditions: [{
              metric: 'error_rate',
              threshold: 5,
              duration: 300
            }]
          }
        ],
        deploymentStrategy: {
          type: 'blue_green',
          blueGreenConfig: {
            healthCheckDelay: 60,
            validationTimeout: 300,
            trafficSwitchDelay: 30
          },
          validation: {
            healthChecks: ['http', 'database'],
            timeout: 300,
            autoRollback: true
          }
        },
        configuration: {
          buildCommands: ['npm run build'],
          testCommands: ['npm test'],
          deployCommands: ['npm run deploy'],
          environmentVariables: new Map([['NODE_ENV', 'production']]),
          artifacts: [],
          security: {
            secretScanning: true,
            vulnerabilityCheck: true,
            complianceCheck: true
          }
        },
        notifications: {
          channels: ['email', 'slack'],
          events: ['start', 'success', 'failure'],
          recipients: ['devops@example.com']
        }
      });

      // 2. Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
      const deploymentMetricsAlert = monitoringSystem.createAlertRule({
        name: 'E2E Deployment Monitor',
        metric: 'deployment.duration',
        condition: 'greater_than',
        threshold: 1800, // 30Î∂Ñ
        severity: 'warning',
        enabled: true,
        description: 'Deployment is taking too long',
        actions: ['email']
      });

      // 3. Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÑ§Ï†ï
      const appHealthCheck = healthDashboard.createHealthCheck({
        name: 'Application Health',
        type: 'application',
        enabled: true,
        interval: 30000,
        timeout: 5000,
        configuration: {
          url: 'https://app.example.com/health',
          expectedStatus: 200
        },
        thresholds: {
          warning: 2000,
          critical: 5000
        },
        dependencies: []
      });

      // 4. Î∞∞Ìè¨ Ïã§Ìñâ
      const execution = await deploymentSystem.executeDeployment(
        pipeline.id,
        'v2.0.0',
        'e2e-test-user',
        { approved: true }
      );

      // 5. Î∞∞Ìè¨ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
      let attempts = 0;
      const maxAttempts = 10;
      
      while (attempts < maxAttempts) {
        const currentExecution = deploymentSystem.getDeploymentStatus(execution.id);
        
        if (currentExecution && ['completed', 'failed', 'cancelled'].includes(currentExecution.status)) {
          break;
        }
        
        // Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ
        await healthDashboard.executeHealthCheck(appHealthCheck.id);
        
        // Î™®ÎãàÌÑ∞ÎßÅ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
        await monitoringSystem.collectAndStoreMetrics();
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        attempts++;
      }

      // 6. ÏµúÏ¢Ö Í≤ÄÏ¶ù
      const finalExecution = deploymentSystem.getDeploymentStatus(execution.id);
      expect(finalExecution).toBeDefined();
      expect(['completed', 'failed']).toContain(finalExecution!.status);

      // 7. ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏
      const finalMonitoringStatus = monitoringSystem.getSystemStatus();
      const finalHealthStatus = healthDashboard.getSystemHealth();
      
      expect(finalMonitoringStatus.overallHealth).toBeDefined();
      expect(finalHealthStatus.overall).toBeDefined();
    });

    it('should handle deployment failure with automatic rollback', async () => {
      // 1. Î°§Î∞± Í∞ÄÎä•Ìïú ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
      const pipeline = deploymentSystem.createPipeline({
        name: 'Rollback Test Pipeline',
        environment: 'staging',
        rollbackEnabled: true,
        stages: [{
          id: 'deploy',
          name: 'Deploy',
          type: 'deploy',
          dependencies: [],
          configuration: {},
          timeoutMinutes: 5,
          retryPolicy: { enabled: false, maxRetries: 0, backoffSeconds: 0 },
          healthChecks: [],
          rollbackConditions: []
        }],
        deploymentStrategy: {
          type: 'rolling',
          validation: {
            healthChecks: ['http'],
            timeout: 300,
            autoRollback: true
          }
        },
        configuration: {
          buildCommands: [],
          testCommands: [],
          deployCommands: ['exit 1'], // Ïã§Ìå®ÌïòÎäî Î™ÖÎ†π
          environmentVariables: new Map(),
          artifacts: [],
          security: {
            secretScanning: false,
            vulnerabilityCheck: false,
            complianceCheck: false
          }
        },
        notifications: {
          channels: ['email'],
          events: ['start', 'success', 'failure'],
          recipients: ['test@example.com']
        }
      });

      // 2. Ïã§Ìå® Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
      const failureAlert = monitoringSystem.createAlertRule({
        name: 'Deployment Failure Alert',
        metric: 'deployment.failures',
        condition: 'greater_than',
        threshold: 0,
        severity: 'critical',
        enabled: true,
        description: 'Deployment failed',
        actions: ['email', 'slack']
      });

      // 3. Î∞∞Ìè¨ Ïã§Ìñâ (Ïã§Ìå® ÏòàÏÉÅ)
      let deploymentFailed = false;
      try {
        await deploymentSystem.executeDeployment(
          pipeline.id,
          'v1.0.1',
          'rollback-test-user',
          { approved: true }
        );
      } catch (_error) {
        deploymentFailed = true;
        expect(_error).toBeDefined();
      }

      // 4. Ïã§Ìå®Í∞Ä Í∞êÏßÄÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      expect(deploymentFailed).toBe(true);

      // 5. Î°§Î∞± Ïã§Ìñâ
      const deploymentHistory = deploymentSystem.getDeploymentHistory(pipeline.id, 1);
      if (deploymentHistory.length > 0) {
        const failedDeployment = deploymentHistory[0];
        
        if (pipeline.rollbackEnabled) {
          const rollbackResult = await deploymentSystem.rollbackDeployment(
            failedDeployment.id,
            'v1.0.0',
            'Rollback due to deployment failure'
          );
          
          expect(rollbackResult).toBeDefined();
          expect(rollbackResult.success).toBeDefined();
          expect(rollbackResult.targetVersion).toBe('v1.0.0');
        }
      }

      // 6. ÏãúÏä§ÌÖú ÏÉÅÌÉúÍ∞Ä Î≥µÍµ¨ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      const postRollbackHealth = healthDashboard.getSystemHealth();
      expect(postRollbackHealth.overall).toBeDefined();
    });
  });

  describe('Performance and Scalability Integration', () => {
    it('should handle multiple concurrent deployments with monitoring', async () => {
      const pipelines = [];
      const executions = [];

      // 1. Ïó¨Îü¨ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
      for (let i = 0; i < 5; i++) {
        const pipeline = deploymentSystem.createPipeline({
          name: `Concurrent Pipeline ${i}`,
          environment: 'development',
          stages: [{
            id: 'deploy',
            name: 'Deploy',
            type: 'deploy',
            dependencies: [],
            configuration: {},
            timeoutMinutes: 5,
            retryPolicy: { enabled: false, maxRetries: 0, backoffSeconds: 0 },
            healthChecks: [],
            rollbackConditions: []
          }],
          deploymentStrategy: {
            type: 'recreate',
            validation: {
              healthChecks: [],
              timeout: 300,
              autoRollback: false
            }
          },
          configuration: {
            buildCommands: [],
            testCommands: [],
            deployCommands: [`echo "deploying pipeline ${i}"`],
            environmentVariables: new Map(),
            artifacts: [],
            security: {
              secretScanning: false,
              vulnerabilityCheck: false,
              complianceCheck: false
            }
          },
          notifications: {
            channels: [],
            events: [],
            recipients: []
          }
        });
        
        pipelines.push(pipeline);
      }

      // 2. Í∞Å ÌååÏù¥ÌîÑÎùºÏù∏Ïóê ÎåÄÌïú Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï
      pipelines.forEach((pipeline, index) => {
        monitoringSystem.createAlertRule({
          name: `Concurrent Deployment Alert ${index}`,
          metric: `deployment.${pipeline.id}.status`,
          condition: 'equals',
          threshold: 'failed',
          severity: 'warning',
          enabled: true,
          description: `Monitor deployment ${index}`,
          actions: ['email']
        });
      });

      // 3. ÎèôÏãú Î∞∞Ìè¨ Ïã§Ìñâ
      const deploymentPromises = pipelines.map((pipeline, index) =>
        deploymentSystem.executeDeployment(
          pipeline.id,
          `v1.0.${index}`,
          'concurrent-test-user',
          { approved: true }
        )
      );

      const results = await Promise.allSettled(deploymentPromises);

      // 4. Í≤∞Í≥º Í≤ÄÏ¶ù
      expect(results.length).toBe(5);
      results.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          expect(result.value).toBeDefined();
          expect(result.value.pipelineId).toBe(pipelines[index].id);
        }
        // ÏùºÎ∂Ä Ïã§Ìå®Îäî ÌóàÏö© (Î¶¨ÏÜåÏä§ Ï†úÏïΩ Îì±ÏúºÎ°ú Ïù∏Ìï¥)
      });

      // 5. Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú ÏÑ±Îä• ÌôïÏù∏
      const monitoringStatus = monitoringSystem.getSystemStatus();
      expect(monitoringStatus.overallHealth).not.toBe('critical');

      // 6. Ìó¨Ïä§ ÎåÄÏãúÎ≥¥Îìú ÏÑ±Îä• ÌôïÏù∏
      const healthStatus = healthDashboard.getSystemHealth();
      expect(healthStatus.overall).toBeDefined();
    });

    it('should maintain system performance under load', async () => {
      const startTime = Date.now();

      // 1. Î©îÌä∏Î¶≠ Îì±Î°ù ÌõÑ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
      for (let i = 0; i < 10; i++) {
        monitoringSystem.registerMetric({
          id: `load.test.metric.${i}`,
          name: `Load Test Metric ${i}`,
          type: 'gauge',
          unit: 'count',
          description: `Load test metric ${i}`,
          aggregation: 'average',
          retention: 86400,
          tags: {}
        });
      }

      // 2. Î©îÌä∏Î¶≠ Îç∞Ïù¥ÌÑ∞ Í∏∞Î°ù
      for (let i = 0; i < 100; i++) {
        monitoringSystem.recordMetric(`load.test.metric.${i % 10}`, Math.random() * 100);
      }

      // 3. Ïó¨Îü¨ Ìó¨Ïä§Ï≤¥ÌÅ¨ Ïã§Ìñâ
      const healthChecks = [];
      for (let i = 0; i < 20; i++) {
        const check = healthDashboard.createHealthCheck({
          name: `Load Test Health Check ${i}`,
          type: 'system',
          enabled: true,
          interval: 30000,
          timeout: 1000,
          configuration: {},
          thresholds: {
            warning: 500,
            critical: 1500
          },
          dependencies: []
        });
        healthChecks.push(check);
      }

      // 4. Î∞∞Ìè¨ ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
      for (let i = 0; i < 10; i++) {
        deploymentSystem.createPipeline({
          name: `Load Test Pipeline ${i}`,
          environment: 'development',
          stages: [],
          deploymentStrategy: {
            type: 'recreate',
            validation: {
              healthChecks: [],
              timeout: 300,
              autoRollback: false
            }
          },
          configuration: {
            buildCommands: [],
            testCommands: [],
            deployCommands: [],
            environmentVariables: new Map(),
            artifacts: [],
            security: {
              secretScanning: false,
              vulnerabilityCheck: false,
              complianceCheck: false
            }
          },
          notifications: {
            channels: [],
            events: [],
            recipients: []
          }
        });
      }

      // 5. ÏãúÏä§ÌÖú ÏùëÎãµ ÏãúÍ∞Ñ Ï∏°Ï†ï
      const responseStart = Date.now();
      
      const [deploymentStatus, monitoringStatus, healthStatus] = await Promise.all([
        Promise.resolve(deploymentSystem.getSystemStatus()),
        Promise.resolve(monitoringSystem.getSystemStatus()),
        Promise.resolve(healthDashboard.getSystemHealth())
      ]);
      
      const responseTime = Date.now() - responseStart;
      const totalTime = Date.now() - startTime;

      // 6. ÏÑ±Îä• Í≤ÄÏ¶ù
      expect(responseTime).toBeLessThan(5000); // 5Ï¥à Ïù¥Ìïò
      expect(totalTime).toBeLessThan(30000); // 30Ï¥à Ïù¥Ìïò

      expect(deploymentStatus).toBeDefined();
      expect(monitoringStatus).toBeDefined();
      expect(healthStatus).toBeDefined();

      // ÏãúÏä§ÌÖúÏù¥ Ïó¨Ï†ÑÌûà Ï†ïÏÉÅ ÏûëÎèôÌï¥Ïïº Ìï®
      expect(['healthy', 'warning']).toContain(deploymentStatus.systemHealth);
      expect(['healthy', 'warning']).toContain(monitoringStatus.overallHealth);
      expect(['healthy', 'degraded']).toContain(healthStatus.overall);
    });
  });

  describe('Data Consistency and Reliability', () => {
    it('should maintain data consistency across system restarts', async () => {
      // 1. Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
      const pipeline = deploymentSystem.createPipeline({
        name: 'Persistence Test Pipeline',
        environment: 'staging',
        stages: [],
        deploymentStrategy: {
          type: 'recreate',
          validation: {
            healthChecks: [],
            timeout: 300,
            autoRollback: false
          }
        },
        configuration: {
          buildCommands: [],
          testCommands: [],
          deployCommands: [],
          environmentVariables: new Map(),
          artifacts: [],
          security: {
            secretScanning: false,
            vulnerabilityCheck: false,
            complianceCheck: false
          }
        },
        notifications: {
          channels: [],
          events: [],
          recipients: []
        }
      });

      const alertRule = monitoringSystem.createAlertRule({
        name: 'Persistence Test Alert',
        metric: 'test.metric',
        condition: 'greater_than',
        threshold: 50,
        severity: 'info',
        enabled: true,
        description: 'Test alert for persistence',
        actions: []
      });

      const healthCheck = healthDashboard.createHealthCheck({
        name: 'Persistence Test Health',
        type: 'system',
        enabled: true,
        interval: 30000,
        timeout: 5000,
        configuration: {},
        thresholds: {
          warning: 1000,
          critical: 3000
        },
        dependencies: []
      });

      // 2. ÏãúÏä§ÌÖú Ïû¨ÏãúÏûë ÏãúÎÆ¨Î†àÏù¥ÏÖò (ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±)
      const newDeploymentSystem = new DeploymentManagementSystem();
      const newMonitoringSystem = new MonitoringAlertingSystem();
      const newHealthDashboard = new HealthStatusDashboard();

      // 3. Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± ÌôïÏù∏
      // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî ÏòÅÏÜçÏÑ± Ï†ÄÏû•ÏÜåÏóêÏÑú Îç∞Ïù¥ÌÑ∞Î•º Î≥µÏõêÌï¥Ïïº Ìï®
      // Ïó¨Í∏∞ÏÑúÎäî ÏãúÏä§ÌÖúÏù¥ Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¥àÍ∏∞ÌôîÎêòÎäîÏßÄ ÌôïÏù∏
      const newDeploymentStatus = newDeploymentSystem.getSystemStatus();
      const newMonitoringStatus = newMonitoringSystem.getSystemStatus();
      const newHealthStatus = newHealthDashboard.getSystemHealth();

      expect(newDeploymentStatus).toBeDefined();
      expect(newMonitoringStatus).toBeDefined();
      expect(newHealthStatus).toBeDefined();

      expect(newDeploymentStatus.systemHealth).toBe('healthy');
      expect(newMonitoringStatus.overallHealth).toBe('healthy');
      expect(newHealthStatus.overall).toBe('healthy');
    });

    it('should handle system failures gracefully', async () => {
      // 1. Ï†ïÏÉÅ ÏÉÅÌÉú ÌôïÏù∏
      const initialDeploymentStatus = deploymentSystem.getSystemStatus();
      const initialMonitoringStatus = monitoringSystem.getSystemStatus();
      const initialHealthStatus = healthDashboard.getSystemHealth();

      expect(initialDeploymentStatus.systemHealth).toBe('healthy');
      expect(initialMonitoringStatus.overallHealth).toBe('healthy');
      expect(initialHealthStatus.overall).toBe('healthy');

      // 2. ÏãúÏä§ÌÖú Î∂ÄÌïò ÏÉùÏÑ± (Î©îÎ™®Î¶¨ ÎàÑÏàò ÏãúÎÆ¨Î†àÏù¥ÏÖò)
      const heavyData = [];
      for (let i = 0; i < 1000; i++) {
        heavyData.push({
          id: i,
          data: new Array(1000).fill(Math.random()),
          timestamp: new Date()
        });

        // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÏãúÏä§ÌÖú ÏÉÅÌÉú ÌôïÏù∏
        if (i % 100 === 0) {
          const currentStatus = monitoringSystem.getSystemStatus();
          if (currentStatus.overallHealth === 'critical') {
            break;
          }
        }
      }

      // 3. ÏãúÏä§ÌÖúÏù¥ Ïó¨Ï†ÑÌûà ÏùëÎãµÌïòÎäîÏßÄ ÌôïÏù∏
      const stressedDeploymentStatus = deploymentSystem.getSystemStatus();
      const stressedMonitoringStatus = monitoringSystem.getSystemStatus();
      const stressedHealthStatus = healthDashboard.getSystemHealth();

      expect(stressedDeploymentStatus).toBeDefined();
      expect(stressedMonitoringStatus).toBeDefined();
      expect(stressedHealthStatus).toBeDefined();

      // ÏãúÏä§ÌÖúÏù¥ ÏôÑÏ†ÑÌûà Ïã§Ìå®ÌïòÏßÄ ÏïäÏïòÎäîÏßÄ ÌôïÏù∏
      expect(stressedDeploymentStatus.systemHealth).not.toBe(undefined);
      expect(stressedMonitoringStatus.overallHealth).not.toBe(undefined);
      expect(stressedHealthStatus.overall).not.toBe(undefined);

      // 4. Ï†ïÎ¶¨ ÏûëÏóÖ
      heavyData.length = 0; // Î©îÎ™®Î¶¨ Ìï¥Ï†ú
    });
  });

  describe('Security and Compliance Integration', () => {
    it('should enforce security policies across all systems', async () => {
      // 1. Î≥¥Ïïà Í∞ïÌôîÎêú ÌååÏù¥ÌîÑÎùºÏù∏ ÏÉùÏÑ±
      const securePipeline = deploymentSystem.createPipeline({
        name: 'Security Test Pipeline',
        environment: 'production',
        stages: [{
          id: 'security-scan',
          name: 'Security Scan',
          type: 'test',
          dependencies: [],
          configuration: {},
          timeoutMinutes: 15,
          retryPolicy: { enabled: true, maxRetries: 1, backoffSeconds: 30 },
          healthChecks: [],
          rollbackConditions: []
        }],
        deploymentStrategy: {
          type: 'blue_green',
          validation: {
            healthChecks: ['http', 'security'],
            timeout: 300,
            autoRollback: true
          }
        },
        configuration: {
          buildCommands: [],
          testCommands: ['npm audit'],
          deployCommands: [],
          environmentVariables: new Map([
            ['NODE_ENV', 'production'],
            ['SECURITY_LEVEL', 'high']
          ]),
          artifacts: [],
          security: {
            secretScanning: true,
            vulnerabilityCheck: true,
            complianceCheck: true
          }
        },
        notifications: {
          channels: ['email', 'slack'],
          events: ['start', 'success', 'failure'],
          recipients: ['security@example.com']
        }
      });

      // 2. Î≥¥Ïïà Î™®ÎãàÌÑ∞ÎßÅ ÏïåÎ¶º ÏÑ§Ï†ï
      const securityAlert = monitoringSystem.createAlertRule({
        name: 'Security Vulnerability Alert',
        metric: 'security.vulnerabilities',
        condition: 'greater_than',
        threshold: 0,
        severity: 'critical',
        enabled: true,
        description: 'Security vulnerabilities detected',
        actions: ['email', 'slack', 'pagerduty']
      });

      // 3. Î≥¥Ïïà Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏÑ§Ï†ï
      const securityHealthCheck = healthDashboard.createHealthCheck({
        name: 'Security Health Check',
        type: 'application',
        enabled: true,
        interval: 300000, // 5Î∂ÑÎßàÎã§
        timeout: 30000,
        configuration: {
          securityEndpoint: '/security/status',
          complianceChecks: ['pci', 'gdpr', 'sox']
        },
        thresholds: {
          warning: 5000,
          critical: 10000
        },
        dependencies: []
      });

      // 4. Î≥¥Ïïà Ï†ïÏ±Ö Í≤ÄÏ¶ù
      expect(securePipeline.configuration.security.secretScanning).toBe(true);
      expect(securePipeline.configuration.security.vulnerabilityCheck).toBe(true);
      expect(securePipeline.configuration.security.complianceCheck).toBe(true);

      expect(securityAlert.severity).toBe('critical');
      expect(securityAlert.actions).toContain('pagerduty');

      expect(securityHealthCheck.configuration.complianceChecks).toContain('gdpr');

      // 5. ÌÜµÌï© Î≥¥Ïïà ÏÉÅÌÉú ÌôïÏù∏
      const securityStatus = {
        deployment: securePipeline.configuration.security,
        monitoring: securityAlert.enabled,
        health: securityHealthCheck.enabled
      };

      expect(securityStatus.deployment.secretScanning).toBe(true);
      expect(securityStatus.monitoring).toBe(true);
      expect(securityStatus.health).toBe(true);
    });

    it('should maintain audit logs across all systems', async () => {
      // 1. Í∞êÏÇ¨ Î°úÍ∑∏ ÏÉùÏÑ± ÌôúÎèô ÏàòÌñâ
      const pipeline = deploymentSystem.createPipeline({
        name: 'Audit Test Pipeline',
        environment: 'production',
        stages: [],
        deploymentStrategy: {
          type: 'recreate',
          validation: {
            healthChecks: [],
            timeout: 300,
            autoRollback: false
          }
        },
        configuration: {
          buildCommands: [],
          testCommands: [],
          deployCommands: [],
          environmentVariables: new Map(),
          artifacts: [],
          security: {
            secretScanning: true,
            vulnerabilityCheck: true,
            complianceCheck: true
          }
        },
        notifications: {
          channels: [],
          events: [],
          recipients: []
        }
      });

      const alertRule = monitoringSystem.createAlertRule({
        name: 'Audit Test Alert',
        metric: 'audit.events',
        condition: 'greater_than',
        threshold: 100,
        severity: 'info',
        enabled: true,
        description: 'High audit event volume',
        actions: ['log']
      });

      const healthCheck = healthDashboard.createHealthCheck({
        name: 'Audit Health Check',
        type: 'system',
        enabled: true,
        interval: 60000,
        timeout: 5000,
        configuration: {
          auditEndpoint: '/audit/health'
        },
        thresholds: {
          warning: 2000,
          critical: 5000
        },
        dependencies: []
      });

      // 2. Í∞êÏÇ¨ Î°úÍ∑∏ Ï°¥Ïû¨ ÌôïÏù∏
      // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Í∞êÏÇ¨ Î°úÍ∑∏ ÏãúÏä§ÌÖúÍ≥º ÌÜµÌï©ÎêòÏñ¥Ïïº Ìï®
      expect(pipeline.id).toBeDefined();
      expect(alertRule.id).toBeDefined();
      expect(healthCheck.id).toBeDefined();

      // 3. ÏãúÏä§ÌÖúÎ≥Ñ Í∞êÏÇ¨ Í∏∞Îä• ÌôïÏù∏
      const deploymentHistory = deploymentSystem.getDeploymentHistory();
      const monitoringStatus = monitoringSystem.getSystemStatus();
      const healthHistory = healthDashboard.getHealthCheckHistory('system', 24);

      expect(Array.isArray(deploymentHistory)).toBe(true);
      expect(monitoringStatus).toBeDefined();
      expect(Array.isArray(healthHistory)).toBe(true);
    });
  });
});