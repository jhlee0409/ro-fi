---
/**
 * 단순화된 챕터 읽기 컴포넌트
 */

interface Props {
  chapterContent: string;
  chapterTitle: string;
  chapterSlug: string;
  className?: string;
}

const { 
  chapterContent, 
  chapterTitle, 
  chapterSlug, 
  className = '' 
} = Astro.props;

// novelSlug와 chapterNumber 추출
const novelSlug = chapterSlug?.split('-ch')[0] || '';
const chapterNumber = chapterSlug?.includes('-ch') 
  ? parseInt(chapterSlug.split('-ch')[1]) || 1
  : 1;

// 챕터 내용을 문단별로 분리 (개선된 처리)
const paragraphs = chapterContent
  .split('\n')
  .filter(p => p.trim().length > 0)
  .map(p => p.trim())
  .filter(p => !p.startsWith('---') && !p.startsWith('**')); // frontmatter와 빈 마크다운 제거


// 단순한 텍스트 표시 (복잡한 분류 제거)
function getParagraphClass(content: string): string {
  return 'novel-text';
}
---

<div class={`simple-chapter-reader reading-content ${className}`}>
  <!-- Chapter Content -->
  <article class="chapter-content space-y-4 max-w-4xl mx-auto">
    {paragraphs.map((paragraph, index) => (
      <p class="text-lg leading-relaxed text-gray-800 mb-4">
        {paragraph}
      </p>
    ))}
  </article>

  <!-- Chapter End -->
  <div class="chapter-end mt-20 mb-16 text-center">
    <div class="novel-scene-break"></div>
    <div class="mt-8 text-stone-400 text-sm">
      - {chapterTitle} 끝 -
    </div>
  </div>

  <!-- Reading Progress (Simple) -->
  <div class="reading-progress fixed bottom-4 right-4 z-40">
    <div class="bg-white/90 backdrop-blur-sm rounded-full p-3 shadow-modern border border-stone-200">
      <div class="w-8 h-8 flex items-center justify-center">
        <span class="text-xs font-bold text-ink-900 reading-progress-text">0%</span>
      </div>
    </div>
  </div>

</div>

<!-- Reading Progress Script -->
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const progressText = document.querySelector('.reading-progress-text');
    
    if (progressText) {
      const updateProgress = () => {
        const scrollTop = window.pageYOffset;
        const docHeight = document.documentElement.scrollHeight - window.innerHeight;
        const scrollProgress = Math.min(scrollTop / docHeight * 100, 100);
        progressText.textContent = `${Math.round(scrollProgress)}%`;
      };
      
      window.addEventListener('scroll', updateProgress);
      updateProgress();
    }
    
    // 키보드 네비게이션
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowDown' || e.key === 'j') {
        e.preventDefault();
        window.scrollBy({ top: 100, behavior: 'smooth' });
      } else if (e.key === 'ArrowUp' || e.key === 'k') {
        e.preventDefault();
        window.scrollBy({ top: -100, behavior: 'smooth' });
      }
    });
  });
</script>

<style>
  /* 단순화된 읽기 스타일 */
  .simple-chapter-reader {
    line-height: 1.8;
    color: hsl(var(--ink-800));
  }
  
  .paragraph-section {
    scroll-margin-top: 6rem;
    padding: 0.5rem 0;
    border-radius: 0.5rem;
    transition: background-color 0.3s ease;
  }
  
  /* 반응형 */
  @media (max-width: 768px) {
    
    .reading-progress {
      bottom: 1rem;
      right: 1rem;
    }
  }
</style>